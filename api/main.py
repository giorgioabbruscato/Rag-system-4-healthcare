from fastapi import FastAPI, UploadFile, File, Form
from pydantic import BaseModel
from typing import Optional, Any, Dict, List
from fastapi.middleware.cors import CORSMiddleware

from api.services.doc_service import save_current_dicom_and_extract_frames, list_current_files, delete_current_file
from api.services.rag_service import answer_question, analyze_current_case

from src.vectorstore_manager import reset_collections


app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class ChatRequest(BaseModel):
    question: str
    model: str
    rag_type: str
    evaluate: bool = False
    session_id: Optional[str] = None

class ChatResponse(BaseModel):
    answer: str
    sources: Optional[List[Dict[str, Any]]] = None
    session_id: Optional[str] = None
    evaluation: Optional[Any] = None


@app.post("/chat", response_model=ChatResponse)
def chat(req: ChatRequest):
    """
    POST /chat
    Accepts a clinical question and RAG parameters. Returns an answer generated by the model, relevant sources, session info, and optional evaluation metrics.
    Request body: question, model, rag_type, evaluate (optional), session_id (optional)
    Response: answer, sources, session_id, evaluation (optional)
    """
    out = answer_question(
        question=req.question,
        model=req.model,
        rag_type=req.rag_type,
        session_id=req.session_id,
        evaluate=req.evaluate,
    )
    return ChatResponse(**out)


@app.post("/upload-doc")
async def upload_doc(
    file: UploadFile = File(...),
):
    """
    POST /upload-doc
    Uploads a DICOM file, extracts frames, and stores the document for further analysis.
    Request: multipart form with a DICOM file.
    Response: ok, plus metadata about the uploaded file and extracted frames.
    """
    result = await save_current_dicom_and_extract_frames(file)
    return {"ok": True, **result}



@app.post("/analyze-case")
async def analyze_case(
    file: UploadFile = File(...),
    report_text: Optional[str] = Form(None)
):
    """
    POST /analyze-case
    Uploads a DICOM file and optional report text, extracts frames, and runs a multimodal RAG analysis to generate a clinical answer.
    Request: multipart form with a DICOM file and optional report_text.
    Response: ok, metadata about the file and frames, and analysis result.
    """
    result = await save_current_dicom_and_extract_frames(file)
    analysis = analyze_current_case(report_text=report_text, frames_dir=result.get("frames_dir"))
    return {"ok": True, **result, "analysis": analysis}



@app.get("/list-docs")
def list_docs(rag_type: str):
    """
    GET /list-docs
    Lists all currently uploaded or indexed documents in the system.
    Query parameter: rag_type (type of documents to list)
    Response: list of documents.
    """
    return list_current_files()



@app.post("/delete-doc")
def delete_doc(payload: Dict[str, Any]):
    """
    POST /delete-doc
    Deletes a document from the current storage.
    Request body: file_id (identifier of the file to delete)
    Response: result of the deletion operation.
    """
    file_id = payload.get("file_id")
    return delete_current_file(file_id)



@app.post("/flush-rag")
def flush_rag():
    """
    POST /flush-rag
    Resets the RAG system by clearing and re-initializing all collections (soft reset).
    Request body: empty or any JSON object.
    Response: ok, message or error.
    """
    try:
        reset_collections()
        return {"ok": True, "message": "RAG collections reset."}
    except Exception as e:
        return {"ok": False, "error": str(e)}, 500
